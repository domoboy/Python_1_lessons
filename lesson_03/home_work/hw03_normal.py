__author__ = 'Коноплянников Николай Иванович'

# Задание-1:
# Напишите функцию, возвращающую ряд Фибоначчи с n-элемента до m-элемента.
# Первыми элементами ряда считать цифры 1 1

'''
Опять математика :'( хнык
Для понимания решения изучено:
Что такое число Фибоначче - https://ru.wikipedia.org/wiki/Числа_Фибоначчи
5 способов вычислить Фибоначчи - https://habr.com/post/261159/
Про разные способы Фибоначчи - http://qaru.site/questions/60043/how-to-write-the-fibonacci-sequence-in-python
Про итераторы/генераторы и yield - https://habr.com/post/132554/
'''


def fi():
    a, b = 1, 1  # Первые элементы ряда
    while True:  # Если истина возвращаем генератор a
        yield a  # Выполняем условие ниже
        a, b = b, a + b  # здесь как в замене a и b без новой переменной a, b = b, a


def sub_fib(n, m):  # Создаем функцию, которая будет показывать числа Фибоначче между n и m
    for cur in fi():  # Начинаем проверку
        if cur > m:  # Если значение стало больше m(верхнего значения) возвращаем результат функции
            return
        if cur >= n:  # Если значение больше или равно начальному значению, запускаем генератор
            yield cur


n = int(input("Введите начальное значение (n):"))
m = int(input("Введите значение m, результатом будут все числа Фибоначче, между n и m"))
print("Ряд Фибоначче в промежутке между {} и {}:".format(n, m))
for i in sub_fib(n, m):  # Для элементов между n и m выводим элементы
    print(i)


# Задача-2:
# Напишите функцию, сортирующую принимаемый список по возрастанию.
# Для сортировки используйте любой алгоритм (например пузырьковый).
# Для решения данной задачи нельзя использовать встроенную функцию и метод sort()

'''
пузырьковый алгоритм. если дан список 3 5 2 8 1, то тройка остается на месте так как она меньше 5, далее проверяется
5, так как 5 больше 2, они меняются местами, 5 < 8, перехожу дальше проверять, и так буду проверять до тех пор, пока
начиная с 0 элемента каждый последующий не будет больше. Самый "легкий пузырек" должен оказаться первым
'''

my_list = [3, 5, 2, 8, 1]  # ver 0.1 задал список


def bubble():
    num = 1  # ввел переменную для проверки
    while num < len(my_list):  # пока длина больше переменной проверки
        for el in range(len(my_list) - num):  # для элементов в диапозоне длины списка - num
            if my_list[el] > my_list[el + 1]:  # если проверяемый элемент в списке больше элемент + 1
                my_list[el], my_list[el + 1] = my_list[el + 1], my_list[el]  # меняем их местами
        num += 1  # добавляем к переменной проверки 1 и начинаем сначала цикл
    print(my_list)


bubble()


'''
Найденное на просторах интернета решение, так называемая шейкерная сортировка, делается 2 прохода сверху вниз и
снизу вверх. Работает быстрее пузырьковой на больших списках

оч интересно - https://habr.com/post/73726/
'''


def shaker_sort(a):
    # lb, ub границы неотсортированной части массива
    k = ub = len(a)-1
    lb = 1
    while lb < ub:
        # проход сверху вниз
        for j in range(ub, lb-1, - 1):
            if a[j - 1] > a[j]:
                a[j - 1], a[j] = a[j], a[j - 1]
                k = j
            lb = k
        # проход снизу вверх
        for j in range(lb, ub + 1):
            if a[j - 1] > a[j]:
                a[j - 1], a[j] = a[j], a[j - 1]
                k = j
            ub = k
    return a


print(shaker_sort([1, 17, 4, 10, 3, 112, 999, 14, 2, 8, 86]))

'''
Самый быстрый, найденный, вариант НЕ МОЙ Сортировка Хоара
Еще называют Быстрая сортировка.
Суть в том, что массив разделется на две части и сортировка происходит отдельно в каждой из групп.
Про сортировку - тут http://py-algorithm.blogspot.com/2011/11/quicksort.html
'''


# def quick_sort(a):
#     w = [x for x in range(4 + len(a) / 2)]  # создаём стек
#     k = 0  # дно
#     w[0] = 0  # указатель на позицию левой границы половины
#     w[1] = len(a) - 1  # -||- правой
#     while k >= 0:
#         i_el = quick_sort_pos(a, w[k], w[k + 1])
#         if i_el != w[k + 1]:
#             rl = i_el + 1  # левая граница правого подъинтервала
#         else:
#             rl = w[k + 1]
#         rr = w[k + 1]  # Правая граница правого подъинтервала
#         ll = w[k]  # Левая граница левого подъинтервал
#         if i_el != w[k]:
#             lr = i_el - 1  # Правая граница левого подъинтервал
#         else:
#             lr = w[k]
#         k -= 2  # удалить текущий интервал
#         if rl != rr:
#             k += 2
#             w[k] = rl
#             w[k + 1] = rr
#         if ll != lr:
#             k += 2
#             w[k] = ll
#             w[k + 1] = lr
#     return
#
#
# def quick_sort_pos(a, left, right):
#     lef = left
#     j = right - 1
#     while True:  # чтобы поставить разделяющий элемент на свое место
#         while a[lef] < a[right]:
#             lef += 1
#         while a[j] > a[right] and j > left:
#             j -= 1
#         if lef >= j:
#             break
#         a[lef], a[j] = a[j], a[lef]
#     a[right], a[lef] = a[lef], a[right]
#     return lef


# Задача-3:
# Напишите собственную реализацию стандартной функции filter.
# Разумеется, внутри нельзя использовать саму функцию filter.

# filter(function, iterable) - Возвращает итератор из тех элементов, для которых function возвращает истину.

user_list = [82, -39, 13, 27, 67, 82, 13, 76, 6, 13, 89, -7, 98, 74, 79, 33, 13, 4, 27]  # Пользовательский список


def my_filter(my_obj, my_arg):  # создается функция с аргументами "объект" и "аргумент"
    new_listing = []  # создается пустой список, в который будут складываться отфильтрованные значения
    for f in my_obj:  # для элемента в объекте
        if f != my_arg:  # если он не соответствует переданному аргументу
            new_listing.append(f)  # добавляем этот элемент в созданный список
    print(new_listing)  # выводим новый отфильтрованный список


my_filter(user_list, 13)  # запускаем функцию - указываем в каком объекте и по какому аргументу фильтровать


# Задача-4:
# Даны четыре точки А1(х1, у1), А2(x2 ,у2), А3(x3 , у3), А4(х4, у4).
# Определить, будут ли они вершинами параллелограмма.

'''
Параллелограмм — четырехугольник, у которого противоположные стороны попарно параллельны.
Чтобы определить решение задачи, сделаем проверку на следующие свойства параллелограмов
- http://www.fmclass.ru/math.php?id=4850e30433b03
- Диагонали параллелограмма точкой пересечения делятся пополам: AO = OC и BO = OD
- В параллелограмме противоположные стороны равны AB = CD и BC = AD
'''

# дам условия для проверки, проверять будем по условиям описанным выше
x1 = 2
x2 = 3
x3 = 6
x4 = 5
y1 = 2
y2 = 4
y3 = 4
y4 = 2

a1 = [x1, y1]
a2 = [x2, y2]
a3 = [x3, y3]
a4 = [x4, y4]
o1 = [(a3[0] + a1[0])/2, (a3[1] + a1[1])/2]  # Диагонали параллелограмма точкой пересечения делятся пополам
o2 = [(a4[0] + a2[0])/2, (a2[1] + a4[1])/2]  # Координаты середины отрезка равны полусуммам координат его концов

# проверяю все условия: что противоположные стороны равны и диагонали делятся пополам
if a3[0] - a2[0] == a4[0] - a1[0] and a2[1] - a1[1] == a3[1] - a4[1] and o1[0] == o2[0] and o1[1] == o2[1]:
    print("Это параллелограмм")
else:
    print("Это не параллелограмм")

